_Сенсоры_ -- представляют собой особый тип (подкласс) операторов. Сенсоры непрерывано опрашивают определенные условия, чтобы определить их истинность, и если условие истинно, то все успешно. В противном случае сенсор будет ждать и повторять попытку до тех пор, пока условие не будет исинно, или время ожидания не истечет.
```python
from airflow.sensors.filesystem import FileSensor

wait_for_supermarket_1 = FileSensor(
	task_id="wait_for_supermarket_1",
    filepath="/data/supermarket1/data.csv",
)
```

Здесь `FileSensor` выполняет проверку на предмет наличия файла `/data/supermarket1/data.csv` и возвращает true, если файл уже существует. В противном случае возвращается false, и сенсор будет ждать в течение заданного периода (по умолачанию 60 секунд) и повторит попытку. У операторов (сенсоры -- это тоже операторы) и ОАГ есть настраиваемые тайм-ауты, и сенсор продолжит проверку условия, пока не истечет время ожидания [[Список литературы#^ae6dac]]<c. 149>

_Покинг_ -- так в Airflow называется запуск сенсора и проверка условия.
### Опрос пользовательских условий

Некоторые наборы данных имеют большой размер и состоят из нескольких файлов (например, `data-01.csv`, `data-02.csv` etc.). `FileSensor` поддерживает подстановочные знаки для соответствия, например, `data-*.csv`, что соответствует любому файлу, совпадающему с шаблоном. Так, если, допустим, первый файл `data-01.csv` был доставлен, а другие все еще загружаются в общее хранилище супермаркетом, `FileSensor` вернет true, и рабочий процесс продолжит выполнение задачи, что нежелательно.

Поэтому мы договорились с супермаркетами записывать файл с именем `_SUCCESS` в качестве последней части загрузки, чтобы указать, что был загружен полный набор ежедневных данных. Группа, работающая с данными, решила, что им нужно проверить наличие одного или нескольких файлов с именем `data-*.csv` и одного файла с именем `_SUCCESS`. Используя шаблоны поиска можно было бы сопоставить несколько шаблонов со сложными шаблоном, однако есть более читабельный подход -- реализовать две проверки с помощью `PythonSensor`.

`PythonSensor` похож на `PythonOperator` в том смысле, что вы предоставляете вызываемый объект Python (функция, метод etc.), который нужно выполнить. Но вызываемый объект `PythonSensor` ограничен возвратом логического значения: `true`, чтобы указать, что условие выполнено успешно, и `false`, чтобы указать, что это не так.
```python
from pathlib import Path
from airflow.sensors.python import PythonSensor

def _wait_for_supermarket(supermarket_id):
    supermarket_path = Path("/data/" + supermarket_id)
    data_files = supermarket_path.glob("data-*.csv")
    success_file = supermarket_path / "_SUCCESS"

    return data_files and success_file.exists()

wait_for_supermaket_1 = PythonSensor(
	task_id = "wait_for_supermarket_1",
	python_callable = _wait_for_supermarket,
	op_kwargs={"supermarket_id": "supermarket1"},
	dag=dag,
)
```

Сенсоры принимают аргумент `timeout`, который содержит максимальное количество секунд, в течение которого может работать. Если в начале очередного покинга количество этих секунд превысит число, заданное для `timeout`, то это приведет к сбою сенсора.

У класса `DAG` есть аргумент `concurrency`, определяющий, сколько параллельных задач разрешено в рамках этого ОАГ.
```python
dag = DAG(
	dag_id="couponing_app",
	start_date=datetime(2019, 1, 1),
	schedule_interval="0 0 * * *",
	concurrency=50,
)
```

==Как только будет достигнут глобальный предел максимального количества задач, вся ваша система встанет, что явно нежелательно==. 

Решить эту проблему можно разными способами. Класс сенсора принимает аргумент `mode`, для которого можно задать значение `"poke"` или `"reschedule"`.

По умолчанию задано значение `"poke"`, что приводит к блокировке. Это означает, что ==задача сенсора занимает слот, пока выполняется==. Время от времени она выполняет покинг, осуществляя проверку условия, а затем ==ничего не делает, но по-прежнему занимает слот==.

Режим сенсора `"rescheulde"` _освобождает слот после завершения покинга_, поэтому слот занят, _только_ пока выполняется работа.
```python
wait_for_supermarket1 = PythonSensor(
	task_id="wait_for_supermarket_1",
	python_callable=_wait_for_supermarket,
	op_kwargs={"supermarket_id": "supermarket1"},
	mode="reschedule",
	dag=dag,
)
```

NB! Сенсоры с режимом `mode = "reschedule"` освобождают свой слот после покинга, позволяя запускать другие задачи.